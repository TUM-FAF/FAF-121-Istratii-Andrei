# WP Laboratory Work #2

## Title

Advanced Form Elements. Child Windows. Basics of Working with the Keyboard

## Contents

  - The Keyboard
  - Child Window Controls
    - Scroll Bar
    - Listbox
  - Menus and Other Resources
  - Dialog Boxes


## Executed Tasks:
  - **Mandatory Tasks:**
    - Display a dialog box on some event.
    - Add a system menu with 3+ items.
    - Add a scrollbar that changes a visible parameter of on element.
    - Hook keyboard input. Add 2 custom events for key combinations.

  - **Tasks With Points:**
    - Add a listbox, attach events to it. (2 pt)
    - Add 2 scroll bars that will manage main window size or position. (1 pt)
    - Customize the application by adding an icon and cursor. (1 pt)
    - Use a scroll bar to scroll through application's working space. Scrolls should appear when necessary. (1 pt)

  - **Additional Tasks:**
    - Use trackbars instead of scrollbars for some controls in order to see how they work.
    - Make it possible to memorize the application state (width, height, background color) and keep it in the list box.
    - Restore a window state when one is double-clicked in the listbox.
    - Add and remove states using the menu and hotkeys: `Ctrl+S` for saving and `Del` for deleting (saving hotkey works from anywhere while the delete key works only when the listbox has input focus)


## Screenshots

1. The application on startup.

![Screenshot1](https://raw.github.com/Andreis13/WP-Labs/master/lab%232/screenshots/1.png)

2. The 'About' dialog box.

![Screenshot2](https://raw.github.com/Andreis13/WP-Labs/master/lab%232/screenshots/2.png)

3. System menu and cursor.

![Screenshot3](https://raw.github.com/Andreis13/WP-Labs/master/lab%232/screenshots/3.png)

4. Changed background and size.

![Screenshot4](https://raw.github.com/Andreis13/WP-Labs/master/lab%232/screenshots/4.png)

5. Working scrollbars for navigating the client area.

![Screenshot5](https://raw.github.com/Andreis13/WP-Labs/master/lab%232/screenshots/5.png)


## A Word on the Workflow

While developing this laboratory work I encountered some interesting things.

The first problem I had to work on was handling the scrollbars and trackbars. It turned out to be a bit complicated because the window procedure receives for both controls the same messages (WM_HSCROLL and WM_VSCROLL), so I had to find out wich control sent the message. First of all I had to differentiated the standard window scrollbars from control versions by checking the `lParam` that came with the message: if it was null then the message was sent by a standard scrollbar, else, it was generated by a control and it stored the HWND of the sender. After that I had to separate the messages from trackbar control and the scrollbar control by retrieving the control Identifier from its HWND (`GetDlgCtrlID((HWND)lParam);`) and finaly handle control-specific messages for each (scroll/track)bar.

The next difficulty was dealing with keyboard input. When the app (main win proc) was listening for the _'Delete'_ WM_KEYDOWN I found out that the message arrived only when the main window had focus i.e. when a trackbar or the listbox was selected, the main window couldn't capture the input. As the key message was needed for the listbox exclusively, the solution was to subclass the lisbox and write a custom procedure which would listen for the necessary keystroke and send the appropriate message to the main window. As for the Ctrl+S combination, it was requied regardless of what window receives keyboard focus. For this one the suitable thing was to register a 'hotkey' which means that the window would receive a high priority WM_HOTKEY message instead of a WM_KEYDOWN, moreover it would come even if the main window doesn't have input focus.

The last problem was storing the window state in order to have the possibility to restore it later. I defined a simple struct that could keep the window width, height and background color (lightness actually). The initial choice for the container was an STL map which had as its keys integers (id of the respective element in the listbox) and as values - the structs defined. At first sight all worked well, however in time I found out that after each deletion from the listbox the IDs were recalculated (they were actually representing the order of the item in the list) i.e. the keys in the map were invalidated. Such behavior was more close to an STL vector, so I changed the container type and it solved the problem.

Overall the laboratory work was quite informative in the matter of handling some more advanced child window controls, one should be careful when messing up with scrollbars. :)